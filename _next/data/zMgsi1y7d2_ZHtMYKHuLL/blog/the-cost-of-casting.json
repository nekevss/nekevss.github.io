{"pageProps":{"meta":{"title":"The cost of casting.","date":"2/4/2024","summary":"Assembly for Dummies - Taking a targeted look into the cost of casting."},"content":"<p>What is the actual cost of casting?</p>\n<p>My goal of writing this is not to write some grand essay or thesis on casting\nvalues between primitive types. The answer may also be quite obvious and easily known\nto some that have a bit more experience. In fact, it may be better to title this\nsimple assembly for dummies.</p>\n<p>I have a very specific use case, and I wanted to take deeper look at the assembly. My\ntargeted question is: would it be more efficient to pass a u32 into a function and\ncast it to a f64 value or just pass an f64?</p>\n<p>Also known as: just how much does the compiler optimize this case.</p>\n<p>So let's take a look at the example code below. It's nothing too special. We have our\nvariables. In one case, we want to complete some addition. In another, we want to\ncomplete some addition but we have to cast our u32 first.</p>\n<pre><code class=\"hljs language-rust\">\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">main</span>() {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">random_base</span>: <span class=\"hljs-type\">f64</span> = <span class=\"hljs-number\">3.5</span>;\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">val_f64</span>: <span class=\"hljs-type\">f64</span> = <span class=\"hljs-number\">2.0</span>;\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">val_u32</span>: <span class=\"hljs-type\">u32</span> = <span class=\"hljs-number\">2</span>;\n\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">result_f64</span> = <span class=\"hljs-title function_ invoke__\">calculate_with_f64</span>(val_f64, random_base);\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">result_u32</span> = <span class=\"hljs-title function_ invoke__\">calculate_with_u32</span>(val_u32, random_base);\n\n    <span class=\"hljs-comment\">// assert!(result_f64 - result_u32 &#x3C;= f64::EPSILON);</span>\n}\n\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">calculate_with_u32</span>(val: <span class=\"hljs-type\">u32</span>, arbitrary: <span class=\"hljs-type\">f64</span>) <span class=\"hljs-punctuation\">-></span> <span class=\"hljs-type\">f64</span> {\n    <span class=\"hljs-type\">f64</span>::<span class=\"hljs-title function_ invoke__\">from</span>(val) + arbitrary\n}\n\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">calculate_with_f64</span>(val: <span class=\"hljs-type\">f64</span>, arbitrary: <span class=\"hljs-type\">f64</span>) <span class=\"hljs-punctuation\">-></span> <span class=\"hljs-type\">f64</span> {\n    val + arbitrary\n}\n\n</code></pre>\n<p>So how exactly does that look when we plug it into <a href=\"https://godbolt.org/\">Compiler Explorer</a></p>\n<pre><code class=\"hljs language-asm\"><span class=\"hljs-symbol\">\n.LCPI0_0:</span>\n<span class=\"hljs-meta\">        .quad</span>   <span class=\"hljs-number\">0x400c000000000000</span>\n<span class=\"hljs-symbol\">.LCPI0_1:</span>\n<span class=\"hljs-meta\">        .quad</span>   <span class=\"hljs-number\">0x4000000000000000</span>\n<span class=\"hljs-symbol\">main:</span>\n        <span class=\"hljs-keyword\">push</span>    <span class=\"hljs-built_in\">rax</span>\n        <span class=\"hljs-keyword\">movsd</span>   <span class=\"hljs-built_in\">xmm0</span>, <span class=\"hljs-built_in\">qword</span> <span class=\"hljs-built_in\">ptr</span> [<span class=\"hljs-built_in\">rip</span> + .LCPI0_1]\n        <span class=\"hljs-keyword\">movsd</span>   <span class=\"hljs-built_in\">xmm1</span>, <span class=\"hljs-built_in\">qword</span> <span class=\"hljs-built_in\">ptr</span> [<span class=\"hljs-built_in\">rip</span> + .LCPI0_0]\n        <span class=\"hljs-keyword\">call</span>    example::calculate_with_f64\n        <span class=\"hljs-keyword\">mov</span>     <span class=\"hljs-built_in\">edi</span>, <span class=\"hljs-number\">2</span>\n        <span class=\"hljs-keyword\">movsd</span>   <span class=\"hljs-built_in\">xmm0</span>, <span class=\"hljs-built_in\">qword</span> <span class=\"hljs-built_in\">ptr</span> [<span class=\"hljs-built_in\">rip</span> + .LCPI0_0]\n        <span class=\"hljs-keyword\">call</span>    example::calculate_with_u32\n        <span class=\"hljs-keyword\">pop</span>     <span class=\"hljs-built_in\">rax</span>\n        <span class=\"hljs-keyword\">ret</span>\n<span class=\"hljs-symbol\">\nexample:</span>:calculate_with_u32:\n        <span class=\"hljs-keyword\">movaps</span>  <span class=\"hljs-built_in\">xmm1</span>, <span class=\"hljs-built_in\">xmm0</span>\n        <span class=\"hljs-keyword\">mov</span>     <span class=\"hljs-built_in\">eax</span>, <span class=\"hljs-built_in\">edi</span>\n        <span class=\"hljs-keyword\">cvtsi2sd</span>        <span class=\"hljs-built_in\">xmm0</span>, <span class=\"hljs-built_in\">rax</span>\n        <span class=\"hljs-keyword\">addsd</span>   <span class=\"hljs-built_in\">xmm0</span>, <span class=\"hljs-built_in\">xmm1</span>\n        <span class=\"hljs-keyword\">ret</span>\n<span class=\"hljs-symbol\">\nexample:</span>:calculate_with_f64:\n        <span class=\"hljs-keyword\">addsd</span>   <span class=\"hljs-built_in\">xmm0</span>, <span class=\"hljs-built_in\">xmm1</span>\n        <span class=\"hljs-keyword\">ret</span>\n\n</code></pre>\n<p>Well there's our answer. There's definitely more instructions to a conversion. What's interesting is just how many\nare actually added in the process. The conversion actually costs 3 instructions: moving the f64 in xmm0 -> xmm1, moving\nthe 2 in edi into eax, and the actual conversion itself.</p>\n<p>Whats even more interesting is what happens if we do a small change in the rust code and call <code>calculate_with_u32</code> before\ncalling <code>calculate_with_f64</code>.</p>\n<pre><code class=\"hljs language-asm\"><span class=\"hljs-symbol\">\n.LCPI0_0:</span>\n<span class=\"hljs-meta\">        .quad</span>   <span class=\"hljs-number\">0x4000000000000000</span>\n<span class=\"hljs-symbol\">.LCPI0_1:</span>\n<span class=\"hljs-meta\">        .quad</span>   <span class=\"hljs-number\">0x400c000000000000</span>\n<span class=\"hljs-symbol\">main:</span>\n        <span class=\"hljs-keyword\">push</span>    <span class=\"hljs-built_in\">rax</span>\n        <span class=\"hljs-keyword\">mov</span>     <span class=\"hljs-built_in\">edi</span>, <span class=\"hljs-number\">2</span>\n        <span class=\"hljs-keyword\">movsd</span>   <span class=\"hljs-built_in\">xmm0</span>, <span class=\"hljs-built_in\">qword</span> <span class=\"hljs-built_in\">ptr</span> [<span class=\"hljs-built_in\">rip</span> + .LCPI0_1]\n        <span class=\"hljs-keyword\">call</span>    example::calculate_with_u32\n        <span class=\"hljs-keyword\">movsd</span>   <span class=\"hljs-built_in\">xmm0</span>, <span class=\"hljs-built_in\">qword</span> <span class=\"hljs-built_in\">ptr</span> [<span class=\"hljs-built_in\">rip</span> + .LCPI0_0]\n        <span class=\"hljs-keyword\">movsd</span>   <span class=\"hljs-built_in\">xmm1</span>, <span class=\"hljs-built_in\">qword</span> <span class=\"hljs-built_in\">ptr</span> [<span class=\"hljs-built_in\">rip</span> + .LCPI0_1]\n        <span class=\"hljs-keyword\">call</span>    example::calculate_with_f64\n        <span class=\"hljs-keyword\">pop</span>     <span class=\"hljs-built_in\">rax</span>\n        <span class=\"hljs-keyword\">ret</span>\n<span class=\"hljs-symbol\">\nexample:</span>:calculate_with_u32:\n        <span class=\"hljs-keyword\">movaps</span>  <span class=\"hljs-built_in\">xmm1</span>, <span class=\"hljs-built_in\">xmm0</span>\n        <span class=\"hljs-keyword\">mov</span>     <span class=\"hljs-built_in\">eax</span>, <span class=\"hljs-built_in\">edi</span>\n        <span class=\"hljs-keyword\">cvtsi2sd</span>        <span class=\"hljs-built_in\">xmm0</span>, <span class=\"hljs-built_in\">rax</span>\n        <span class=\"hljs-keyword\">addsd</span>   <span class=\"hljs-built_in\">xmm0</span>, <span class=\"hljs-built_in\">xmm1</span>\n        <span class=\"hljs-keyword\">ret</span>\n<span class=\"hljs-symbol\">\nexample:</span>:calculate_with_f64:\n        <span class=\"hljs-keyword\">addsd</span>   <span class=\"hljs-built_in\">xmm0</span>, <span class=\"hljs-built_in\">xmm1</span>\n        <span class=\"hljs-keyword\">ret</span>\n\n</code></pre>\n<p>It's actually fairly interesting in my mind, probably from utter lack of experience,\nbut we can really see some fascinating optimizations around computers.</p>\n<h2>Some Questions and Thoughts</h2>\n<ul>\n<li>There's something weird happening with storing in <code>edi</code> over <code>eax</code></li>\n<li>The order of the constants inverted between .LCPI0_0 and .LCPI0_1 for no apparent reason.</li>\n<li>Compilers are really, really cool</li>\n</ul>\n<p>I can't help but wonder exactly why 2 is stored in <code>edi</code> over preemptively storing the\nvalue into <code>eax</code>. If I had to take a blind guess, it may be that <code>rax</code> or <code>eax</code> are\nreserved with the call instruction. That or it's bad practice as some functions may\npush <code>rax</code> onto the stack (even though we can see that ours don't).</p>\n<p>Preemptively pushing to <code>eax</code> would save the <code>mov</code> from <code>eax</code> to <code>edi</code> in this scenario,\nbut in larger codebases, we may not know if the callee invokes <code>push rax</code>, which would\nthan corrupt <code>eax</code>.</p>\n<p>It could also be that <code>eax</code> is reserved for function parameters. I have seen that mentioned\nonline, but no way of confirming either one really.</p>\n<p>Side note: for those not entirely familiar with / newer to assembly (like myself) <code>eax</code>\nand <code>rax</code> are basically one in the same ... but also not. <code>eax</code> is actually the lower\nbits of <code>rax</code></p>\n<p>The below is essentially a simple ASCII depiction of the <code>rax</code> and <code>eax</code> registers.</p>\n<pre><code class=\"hljs language-txt\">\n +-----------------------------------------------------+\n |                         rax                         |\n +--------------------------+--------------------------+\n |                          |                          |\n |                          |                          |\n |                          |                          |\n |           eax            |                          |\n |                          |                          |\n |                          |                          |\n |                          |                          |\n +--------------------------+--------------------------+\n\n</code></pre>\n<p>You learn something new everyday!</p>\n<p>Now as far as the change between the local constant LCPI0_0 and LCPI0_1. It appears that LCPI0_1 is called first in\nboth compiled assembly outputs. The difference is the functions they are being called for.</p>\n<p>Another blind guess, local constants are being tracked on a stack and then unwinding the stack is how they are established\nand labelled. The jury is also out on some small optimzation, but it's probably just a stack. Interesting nonetheless!</p>\n<h2>Conclusion</h2>\n<p>Assembly is actually pretty cool. I don't think I would ever want to write anything in pure assembly. But it really\nallows you to appreciate what the compiler is doing and peek behind the frontend of some of these languages.</p>\n<p>Who knows, maybe there's more small posts like these to come.</p>\n<p>Until next time!</p>"},"__N_SSG":true}