{"pageProps":{"meta":{"title":"Weekly Update 1","date":"8/24/2023"},"content":"<p>I'm going to try and write a post like this every week or two. Why? As personal encouragement\nto keep writing and blogging. Hopefully in the future I'll be able to write something\nmore meaningful. Let's think of them more as a weekly diary than anything of use.</p>\n<h2>Some Forest Themes</h2>\n<p>Let's start out with the banger. I made my own theme for VS Code(unreleased)! I've called\nit Foggy Forest based off the inspirational photo and color palette. My hope is to work\non a Fall Forest and Winter Forest theme as well. But there are also other things to work\non (see below) and I still need to work out the kinks of Foggy Forest. But I'm really\nlooking forward to completeing them. Who knows, maybe I'll actually release them.</p>\n<h2>Debugger Update</h2>\n<p>After some clean up, I submitted a draft of providing access to the trace via hooks. The\nfeedback that I got was great! At least, what feedback I've gotten to this point. It was\nprimarily to switch to a trait based approach, which is definitely more streamlined.</p>\n<p>The trace works in more of an event-based manner, at least how I imagine it. We reach an\nexecution point and we emit a \"message\". But with switching to a Trace and the added\nfunctionality and provided implementation, I'm curious if instead of emitting precomposed\nmessages that emitting raw data would actually be better. The messages then could be provided\nvia some defaults.</p>\n<p>It opens the door on customization while keeping the utility. However, is there such a thing\nas providing too much access to information.</p>\n<p>To be determined.</p>\n<h2>Temporal Work</h2>\n<p>After maybe a month off, I started back up working on the Temporal branch. Hopefully, no one\nhas started within the last month. It felt good. I'm actually making pretty solid progress\non it. I'm thinking an early version that could be merged is maybe a week to a week and a half\naway.</p>\n<p>I don't expect to have it 100% complete. But I'm honestly concerned with how large the changes\nare starting to become. I have this idea in my head to push for it to be merged ideally in\nSeptember that way some of the unimplemented aspects are available for Hacktober for potential\nnew contributors.</p>\n<p>The other maintainers may disagree with doing it that way though, which would be understandable.\nI'm planning to work on it either way. I would also like to offer someone else the chance to\ncontribute on this project in a manageable like I was able to at first with <code>Array.prototype.at</code>.</p>\n<h2>New Rust Version</h2>\n<p>Okay, so this one is actually exciting! But kind of painful. The new version of Rust was released!\nAnd a new wave of Clippy lints came out that Boa's CI ran into face first.</p>\n<p>The big one: Missing panic docs.</p>\n<p>Honestly, this one is deserved. We use expect pretty liberally in the engine where we know the value\ncannot fail per spec, and it failing would be an implementation error. The question I had was: do\nwe update the docs to note the panics if they should not happen in theory or do we update the code\nand adapt the errors to a runtime JavaScript <code>ImplementationError</code>.</p>\n<p>And the other one, which is a super interesting change and way of thinking about writing rust.</p>\n<p>Let's look at the below example (which I may have to change since this one may be too simple).</p>\n<pre><code class=\"hljs language-rust\">\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">main</span>() {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">cars</span> = <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-string\">\"soul\"</span>, <span class=\"hljs-string\">\"F250\"</span>, <span class=\"hljs-string\">\"prius\"</span>, <span class=\"hljs-string\">\"mustang\"</span>];\n\n    <span class=\"hljs-keyword\">for</span> <span class=\"hljs-variable\">car</span> <span class=\"hljs-keyword\">in</span> cars.<span class=\"hljs-title function_ invoke__\">iter</span>() {\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{car}\"</span>)\n    }\n}\n\n</code></pre>\n<p>Did you catch it? Neither would I!</p>\n<pre><code class=\"hljs language-rust\">\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">main</span>() {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">cars</span> = <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-string\">\"soul\"</span>, <span class=\"hljs-string\">\"F250\"</span>, <span class=\"hljs-string\">\"prius\"</span>, <span class=\"hljs-string\">\"mustang\"</span>];\n\n    <span class=\"hljs-keyword\">for</span> <span class=\"hljs-variable\">car</span> <span class=\"hljs-keyword\">in</span> &#x26;cars {\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{car}\"</span>)\n    }\n}\n\n</code></pre>\n<p>Instead of the use of <code>iter()</code>, the change is to recommend leading with a <code>&#x26;</code>. It's an interesting change\nthat is then pushed even further. For instance:</p>\n<pre><code class=\"hljs language-rust\">\n<span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Dealership</span> {\n    cars: <span class=\"hljs-type\">Vec</span>&#x3C;&#x26;<span class=\"hljs-symbol\">'static</span> <span class=\"hljs-type\">str</span>>\n}\n\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">main</span>() {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">cars</span> = <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-string\">\"soul\"</span>, <span class=\"hljs-string\">\"F250\"</span>, <span class=\"hljs-string\">\"prius\"</span>, <span class=\"hljs-string\">\"mustang\"</span>];\n\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">dealer</span> = Dealership {\n        cars\n    };\n\n    <span class=\"hljs-keyword\">for</span> <span class=\"hljs-variable\">car</span> <span class=\"hljs-keyword\">in</span> dealer.cars.<span class=\"hljs-title function_ invoke__\">iter</span>() {\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{car}\"</span>)\n    }\n}\n\n</code></pre>\n<p>This example is also included in the change! But instead of just a borrow(<code>&#x26;</code>), we deref(*) cars and\nthen borrow it (&#x26;), which results in the below <code>&#x26;*</code>.</p>\n<pre><code class=\"hljs language-rust\">\n<span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Dealership</span> {\n    cars: <span class=\"hljs-type\">Vec</span>&#x3C;&#x26;<span class=\"hljs-symbol\">'static</span> <span class=\"hljs-type\">str</span>>\n}\n\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">main</span>() {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">cars</span> = <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-string\">\"soul\"</span>, <span class=\"hljs-string\">\"F250\"</span>, <span class=\"hljs-string\">\"prius\"</span>, <span class=\"hljs-string\">\"mustang\"</span>];\n\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">dealer</span> = Dealership {\n        cars\n    };\n\n    <span class=\"hljs-keyword\">for</span> <span class=\"hljs-variable\">car</span> <span class=\"hljs-keyword\">in</span> &#x26;*cars.<span class=\"hljs-title function_ invoke__\">iter</span>() {\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{car}\"</span>)\n    }\n}\n\n</code></pre>\n<p>It's definitely a change that may take some time for me to get used to it. But so far, I think it's\npretty nice.</p>"},"__N_SSG":true}