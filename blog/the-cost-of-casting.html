<!DOCTYPE html><html lang="en-us"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>Blog | The cost of casting.</title><meta name="next-head-count" content="3"/><link rel="shortcut icon" href="/images/favicon.ico"/><link rel="alternate" type="rss+xml" title="Blog" href="https://nekevss.github.io/rss/feed.xml"/><link rel="preload" href="https://nekevss.github.io/_next/static/css/671f1d53c380e83e.css" as="style" crossorigin=""/><link rel="stylesheet" href="https://nekevss.github.io/_next/static/css/671f1d53c380e83e.css" crossorigin="" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="https://nekevss.github.io/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="https://nekevss.github.io/_next/static/chunks/webpack-31fb61886a5e36ee.js" defer="" crossorigin=""></script><script src="https://nekevss.github.io/_next/static/chunks/framework-0c7baedefba6b077.js" defer="" crossorigin=""></script><script src="https://nekevss.github.io/_next/static/chunks/main-7af7d5359a6145de.js" defer="" crossorigin=""></script><script src="https://nekevss.github.io/_next/static/chunks/pages/_app-4d01bdb41bf19633.js" defer="" crossorigin=""></script><script src="https://nekevss.github.io/_next/static/chunks/pages/blog/%5Bslug%5D-4e64d5f798a4bd1f.js" defer="" crossorigin=""></script><script src="https://nekevss.github.io/_next/static/XPwiApdXAcqtI3u-hHfVF/_buildManifest.js" defer="" crossorigin=""></script><script src="https://nekevss.github.io/_next/static/XPwiApdXAcqtI3u-hHfVF/_ssgManifest.js" defer="" crossorigin=""></script></head><body><div id="__next"><nav class="flex items-center justify-between flex-wrap p-6"><div class="w-full block flex-grow lg:flex lg:items-center lg:w-auto"><a class="p-2 text-center rounded text-sm lg:text-xl mx-1.5 hover:bg-theme" href="/">Home</a><a class="p-2 text-center rounded text-sm lg:text-xl mx-1.5 hover:bg-theme" href="/about">About</a><a class="p-2 text-center rounded text-sm lg:text-xl mx-1.5 hover:bg-theme" href="/blog">Blog</a><a class="p-2 text-center rounded text-sm lg:text-xl mx-1.5 hover:bg-theme" href="https://github.com/nekevss">Github</a></div></nav><main class="h-full"><div class="flex min-h-screen flex-col items-center"><div class="w-10/12 h-1/6 mx-auto justify-items-center"><h1 class="text-4xl font-bold text-center">The cost of casting.</h1><h3 class="text-xl text-center my-2">2/4/2024</h3></div><div class="min-h-min w-5/6 lg:w-2/5 mx-auto my-8 justify-items-between"><p class="my-6">What is the actual cost of casting?</p>
<p class="my-6">My goal of writing this is not to write some grand essay or thesis on casting
values between primitive types. The answer may also be quite obvious and easily known
to some that have a bit more experience. In fact, it may be better to title this
simple assembly for dummies.</p>
<p class="my-6">I have a very specific use case, and I wanted to take deeper look at the assembly. My
targeted question is: would it be more efficient to pass a u32 into a function and
cast it to a f64 value or just pass an f64?</p>
<p class="my-6">Also known as: just how much does the compiler optimize this case.</p>
<p class="my-6">So let's take a look at the example code below. It's nothing too special. We have our
variables. In one case, we want to complete some addition. In another, we want to
complete some addition but we have to cast our u32 first.</p>
<pre class="w-full whitespace-pre overflow-x-auto lg:whitespace-pre-wrap bg-theme rounded-lg font-mono py-1 px-3"><code class="hljs language-rust">
<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-variable">random_base</span>: <span class="hljs-type">f64</span> = <span class="hljs-number">3.5</span>;
    <span class="hljs-keyword">let</span> <span class="hljs-variable">val_f64</span>: <span class="hljs-type">f64</span> = <span class="hljs-number">2.0</span>;
    <span class="hljs-keyword">let</span> <span class="hljs-variable">val_u32</span>: <span class="hljs-type">u32</span> = <span class="hljs-number">2</span>;

    <span class="hljs-keyword">let</span> <span class="hljs-variable">result_f64</span> = <span class="hljs-title function_ invoke__">calculate_with_f64</span>(val_f64, random_base);
    <span class="hljs-keyword">let</span> <span class="hljs-variable">result_u32</span> = <span class="hljs-title function_ invoke__">calculate_with_u32</span>(val_u32, random_base);

    <span class="hljs-comment">// assert!(result_f64 - result_u32 &#x3C;= f64::EPSILON);</span>
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">calculate_with_u32</span>(val: <span class="hljs-type">u32</span>, arbitrary: <span class="hljs-type">f64</span>) <span class="hljs-punctuation">-></span> <span class="hljs-type">f64</span> {
    <span class="hljs-type">f64</span>::<span class="hljs-title function_ invoke__">from</span>(val) + arbitrary
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">calculate_with_f64</span>(val: <span class="hljs-type">f64</span>, arbitrary: <span class="hljs-type">f64</span>) <span class="hljs-punctuation">-></span> <span class="hljs-type">f64</span> {
    val + arbitrary
}

</code></pre>
<p class="my-6">So how exactly does that look when we plug it into <a href="https://godbolt.org/">Compiler Explorer</a></p>
<pre class="w-full whitespace-pre overflow-x-auto lg:whitespace-pre-wrap bg-theme rounded-lg font-mono py-1 px-3"><code class="hljs language-asm"><span class="hljs-symbol">
.LCPI0_0:</span>
<span class="hljs-meta">        .quad</span>   <span class="hljs-number">0x400c000000000000</span>
<span class="hljs-symbol">.LCPI0_1:</span>
<span class="hljs-meta">        .quad</span>   <span class="hljs-number">0x4000000000000000</span>
<span class="hljs-symbol">main:</span>
        <span class="hljs-keyword">push</span>    <span class="hljs-built_in">rax</span>
        <span class="hljs-keyword">movsd</span>   <span class="hljs-built_in">xmm0</span>, <span class="hljs-built_in">qword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">rip</span> + .LCPI0_1]
        <span class="hljs-keyword">movsd</span>   <span class="hljs-built_in">xmm1</span>, <span class="hljs-built_in">qword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">rip</span> + .LCPI0_0]
        <span class="hljs-keyword">call</span>    example::calculate_with_f64
        <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">edi</span>, <span class="hljs-number">2</span>
        <span class="hljs-keyword">movsd</span>   <span class="hljs-built_in">xmm0</span>, <span class="hljs-built_in">qword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">rip</span> + .LCPI0_0]
        <span class="hljs-keyword">call</span>    example::calculate_with_u32
        <span class="hljs-keyword">pop</span>     <span class="hljs-built_in">rax</span>
        <span class="hljs-keyword">ret</span>
<span class="hljs-symbol">
example:</span>:calculate_with_u32:
        <span class="hljs-keyword">movaps</span>  <span class="hljs-built_in">xmm1</span>, <span class="hljs-built_in">xmm0</span>
        <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">edi</span>
        <span class="hljs-keyword">cvtsi2sd</span>        <span class="hljs-built_in">xmm0</span>, <span class="hljs-built_in">rax</span>
        <span class="hljs-keyword">addsd</span>   <span class="hljs-built_in">xmm0</span>, <span class="hljs-built_in">xmm1</span>
        <span class="hljs-keyword">ret</span>
<span class="hljs-symbol">
example:</span>:calculate_with_f64:
        <span class="hljs-keyword">addsd</span>   <span class="hljs-built_in">xmm0</span>, <span class="hljs-built_in">xmm1</span>
        <span class="hljs-keyword">ret</span>

</code></pre>
<p class="my-6">Well there's our answer. There's definitely more instructions to a conversion. What's interesting is just how many
are actually added in the process. The conversion actually costs 3 instructions: moving the f64 in xmm0 -> xmm1, moving
the 2 in edi into eax, and the actual conversion itself.</p>
<p class="my-6">Whats even more interesting is what happens if we do a small change in the rust code and call <code class="bg-theme overflow-x-auto rounded-sm font-mono px-1">calculate_with_u32</code> before
calling <code class="bg-theme overflow-x-auto rounded-sm font-mono px-1">calculate_with_f64</code>.</p>
<pre class="w-full whitespace-pre overflow-x-auto lg:whitespace-pre-wrap bg-theme rounded-lg font-mono py-1 px-3"><code class="hljs language-asm"><span class="hljs-symbol">
.LCPI0_0:</span>
<span class="hljs-meta">        .quad</span>   <span class="hljs-number">0x4000000000000000</span>
<span class="hljs-symbol">.LCPI0_1:</span>
<span class="hljs-meta">        .quad</span>   <span class="hljs-number">0x400c000000000000</span>
<span class="hljs-symbol">main:</span>
        <span class="hljs-keyword">push</span>    <span class="hljs-built_in">rax</span>
        <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">edi</span>, <span class="hljs-number">2</span>
        <span class="hljs-keyword">movsd</span>   <span class="hljs-built_in">xmm0</span>, <span class="hljs-built_in">qword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">rip</span> + .LCPI0_1]
        <span class="hljs-keyword">call</span>    example::calculate_with_u32
        <span class="hljs-keyword">movsd</span>   <span class="hljs-built_in">xmm0</span>, <span class="hljs-built_in">qword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">rip</span> + .LCPI0_0]
        <span class="hljs-keyword">movsd</span>   <span class="hljs-built_in">xmm1</span>, <span class="hljs-built_in">qword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">rip</span> + .LCPI0_1]
        <span class="hljs-keyword">call</span>    example::calculate_with_f64
        <span class="hljs-keyword">pop</span>     <span class="hljs-built_in">rax</span>
        <span class="hljs-keyword">ret</span>
<span class="hljs-symbol">
example:</span>:calculate_with_u32:
        <span class="hljs-keyword">movaps</span>  <span class="hljs-built_in">xmm1</span>, <span class="hljs-built_in">xmm0</span>
        <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">edi</span>
        <span class="hljs-keyword">cvtsi2sd</span>        <span class="hljs-built_in">xmm0</span>, <span class="hljs-built_in">rax</span>
        <span class="hljs-keyword">addsd</span>   <span class="hljs-built_in">xmm0</span>, <span class="hljs-built_in">xmm1</span>
        <span class="hljs-keyword">ret</span>
<span class="hljs-symbol">
example:</span>:calculate_with_f64:
        <span class="hljs-keyword">addsd</span>   <span class="hljs-built_in">xmm0</span>, <span class="hljs-built_in">xmm1</span>
        <span class="hljs-keyword">ret</span>

</code></pre>
<p class="my-6">It's actually fairly interesting in my mind, probably from utter lack of experience,
but we can really see some fascinating optimizations around computers.</p>
<h2 class="text-xl font-bold text-center my-8">Some Questions and Thoughts</h2>
<ul>
<li>There's something weird happening with storing in <code class="bg-theme overflow-x-auto rounded-sm font-mono px-1">edi</code> over <code class="bg-theme overflow-x-auto rounded-sm font-mono px-1">eax</code></li>
<li>The order of the constants inverted between .LCPI0_0 and .LCPI0_1 for no apparent reason.</li>
<li>Compilers are really, really cool</li>
</ul>
<p class="my-6">I can't help but wonder exactly why 2 is stored in <code class="bg-theme overflow-x-auto rounded-sm font-mono px-1">edi</code> over preemptively storing the
value into <code class="bg-theme overflow-x-auto rounded-sm font-mono px-1">eax</code>. If I had to take a blind guess, it may be that <code class="bg-theme overflow-x-auto rounded-sm font-mono px-1">rax</code> or <code class="bg-theme overflow-x-auto rounded-sm font-mono px-1">eax</code> are
reserved with the call instruction. That or it's bad practice as some functions may
push <code class="bg-theme overflow-x-auto rounded-sm font-mono px-1">rax</code> onto the stack (even though we can see that ours don't).</p>
<p class="my-6">Preemptively pushing to <code class="bg-theme overflow-x-auto rounded-sm font-mono px-1">eax</code> would save the <code class="bg-theme overflow-x-auto rounded-sm font-mono px-1">mov</code> from <code class="bg-theme overflow-x-auto rounded-sm font-mono px-1">eax</code> to <code class="bg-theme overflow-x-auto rounded-sm font-mono px-1">edi</code> in this scenario,
but in larger codebases, we may not know if the callee invokes <code class="bg-theme overflow-x-auto rounded-sm font-mono px-1">push rax</code>, which would
than corrupt <code class="bg-theme overflow-x-auto rounded-sm font-mono px-1">eax</code>.</p>
<p class="my-6">It could also be that <code class="bg-theme overflow-x-auto rounded-sm font-mono px-1">eax</code> is reserved for function parameters. I have seen that mentioned
online, but no way of confirming either one really.</p>
<p class="my-6">Side note: for those not entirely familiar with / newer to assembly (like myself) <code class="bg-theme overflow-x-auto rounded-sm font-mono px-1">eax</code>
and <code class="bg-theme overflow-x-auto rounded-sm font-mono px-1">rax</code> are basically one in the same ... but also not. <code class="bg-theme overflow-x-auto rounded-sm font-mono px-1">eax</code> is actually the lower
bits of <code class="bg-theme overflow-x-auto rounded-sm font-mono px-1">rax</code></p>
<p class="my-6">The below is essentially a simple ASCII depiction of the <code class="bg-theme overflow-x-auto rounded-sm font-mono px-1">rax</code> and <code class="bg-theme overflow-x-auto rounded-sm font-mono px-1">eax</code> registers.</p>
<pre class="w-full whitespace-pre overflow-x-auto lg:whitespace-pre-wrap bg-theme rounded-lg font-mono py-1 px-3"><code class="hljs language-txt">
 +-----------------------------------------------------+
 |                         rax                         |
 +--------------------------+--------------------------+
 |                          |                          |
 |                          |                          |
 |                          |                          |
 |           eax            |                          |
 |                          |                          |
 |                          |                          |
 |                          |                          |
 +--------------------------+--------------------------+

</code></pre>
<p class="my-6">You learn something new everyday!</p>
<p class="my-6">Now as far as the change between the local constant LCPI0_0 and LCPI0_1. It appears that LCPI0_1 is called first in
both compiled assembly outputs. The difference is the functions they are being called for.</p>
<p class="my-6">Another blind guess, local constants are being tracked on a stack and then unwinding the stack is how they are established
and labelled. The jury is also out on some small optimzation, but it's probably just a stack. Interesting nonetheless!</p>
<h2 class="text-xl font-bold text-center my-8">Conclusion</h2>
<p class="my-6">Assembly is actually pretty cool. I don't think I would ever want to write anything in pure assembly. But it really
allows you to appreciate what the compiler is doing and peek behind the frontend of some of these languages.</p>
<p class="my-6">Who knows, maybe there's more small posts like these to come.</p>
<p class="my-6">Until next time!</p></div></div></main></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"meta":{"title":"The cost of casting.","date":"2/4/2024","summary":"Assembly for Dummies - Taking a targeted look into the cost of casting."},"content":"\u003cp\u003eWhat is the actual cost of casting?\u003c/p\u003e\n\u003cp\u003eMy goal of writing this is not to write some grand essay or thesis on casting\nvalues between primitive types. The answer may also be quite obvious and easily known\nto some that have a bit more experience. In fact, it may be better to title this\nsimple assembly for dummies.\u003c/p\u003e\n\u003cp\u003eI have a very specific use case, and I wanted to take deeper look at the assembly. My\ntargeted question is: would it be more efficient to pass a u32 into a function and\ncast it to a f64 value or just pass an f64?\u003c/p\u003e\n\u003cp\u003eAlso known as: just how much does the compiler optimize this case.\u003c/p\u003e\n\u003cp\u003eSo let's take a look at the example code below. It's nothing too special. We have our\nvariables. In one case, we want to complete some addition. In another, we want to\ncomplete some addition but we have to cast our u32 first.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\n\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e() {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003erandom_base\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003ef64\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e3.5\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eval_f64\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003ef64\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e2.0\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eval_u32\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eu32\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e;\n\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eresult_f64\u003c/span\u003e = \u003cspan class=\"hljs-title function_ invoke__\"\u003ecalculate_with_f64\u003c/span\u003e(val_f64, random_base);\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eresult_u32\u003c/span\u003e = \u003cspan class=\"hljs-title function_ invoke__\"\u003ecalculate_with_u32\u003c/span\u003e(val_u32, random_base);\n\n    \u003cspan class=\"hljs-comment\"\u003e// assert!(result_f64 - result_u32 \u0026#x3C;= f64::EPSILON);\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecalculate_with_u32\u003c/span\u003e(val: \u003cspan class=\"hljs-type\"\u003eu32\u003c/span\u003e, arbitrary: \u003cspan class=\"hljs-type\"\u003ef64\u003c/span\u003e) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003ef64\u003c/span\u003e {\n    \u003cspan class=\"hljs-type\"\u003ef64\u003c/span\u003e::\u003cspan class=\"hljs-title function_ invoke__\"\u003efrom\u003c/span\u003e(val) + arbitrary\n}\n\n\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecalculate_with_f64\u003c/span\u003e(val: \u003cspan class=\"hljs-type\"\u003ef64\u003c/span\u003e, arbitrary: \u003cspan class=\"hljs-type\"\u003ef64\u003c/span\u003e) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003ef64\u003c/span\u003e {\n    val + arbitrary\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSo how exactly does that look when we plug it into \u003ca href=\"https://godbolt.org/\"\u003eCompiler Explorer\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-asm\"\u003e\u003cspan class=\"hljs-symbol\"\u003e\n.LCPI0_0:\u003c/span\u003e\n\u003cspan class=\"hljs-meta\"\u003e        .quad\u003c/span\u003e   \u003cspan class=\"hljs-number\"\u003e0x400c000000000000\u003c/span\u003e\n\u003cspan class=\"hljs-symbol\"\u003e.LCPI0_1:\u003c/span\u003e\n\u003cspan class=\"hljs-meta\"\u003e        .quad\u003c/span\u003e   \u003cspan class=\"hljs-number\"\u003e0x4000000000000000\u003c/span\u003e\n\u003cspan class=\"hljs-symbol\"\u003emain:\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003epush\u003c/span\u003e    \u003cspan class=\"hljs-built_in\"\u003erax\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003emovsd\u003c/span\u003e   \u003cspan class=\"hljs-built_in\"\u003exmm0\u003c/span\u003e, \u003cspan class=\"hljs-built_in\"\u003eqword\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eptr\u003c/span\u003e [\u003cspan class=\"hljs-built_in\"\u003erip\u003c/span\u003e + .LCPI0_1]\n        \u003cspan class=\"hljs-keyword\"\u003emovsd\u003c/span\u003e   \u003cspan class=\"hljs-built_in\"\u003exmm1\u003c/span\u003e, \u003cspan class=\"hljs-built_in\"\u003eqword\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eptr\u003c/span\u003e [\u003cspan class=\"hljs-built_in\"\u003erip\u003c/span\u003e + .LCPI0_0]\n        \u003cspan class=\"hljs-keyword\"\u003ecall\u003c/span\u003e    example::calculate_with_f64\n        \u003cspan class=\"hljs-keyword\"\u003emov\u003c/span\u003e     \u003cspan class=\"hljs-built_in\"\u003eedi\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003emovsd\u003c/span\u003e   \u003cspan class=\"hljs-built_in\"\u003exmm0\u003c/span\u003e, \u003cspan class=\"hljs-built_in\"\u003eqword\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eptr\u003c/span\u003e [\u003cspan class=\"hljs-built_in\"\u003erip\u003c/span\u003e + .LCPI0_0]\n        \u003cspan class=\"hljs-keyword\"\u003ecall\u003c/span\u003e    example::calculate_with_u32\n        \u003cspan class=\"hljs-keyword\"\u003epop\u003c/span\u003e     \u003cspan class=\"hljs-built_in\"\u003erax\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003eret\u003c/span\u003e\n\u003cspan class=\"hljs-symbol\"\u003e\nexample:\u003c/span\u003e:calculate_with_u32:\n        \u003cspan class=\"hljs-keyword\"\u003emovaps\u003c/span\u003e  \u003cspan class=\"hljs-built_in\"\u003exmm1\u003c/span\u003e, \u003cspan class=\"hljs-built_in\"\u003exmm0\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003emov\u003c/span\u003e     \u003cspan class=\"hljs-built_in\"\u003eeax\u003c/span\u003e, \u003cspan class=\"hljs-built_in\"\u003eedi\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003ecvtsi2sd\u003c/span\u003e        \u003cspan class=\"hljs-built_in\"\u003exmm0\u003c/span\u003e, \u003cspan class=\"hljs-built_in\"\u003erax\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003eaddsd\u003c/span\u003e   \u003cspan class=\"hljs-built_in\"\u003exmm0\u003c/span\u003e, \u003cspan class=\"hljs-built_in\"\u003exmm1\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003eret\u003c/span\u003e\n\u003cspan class=\"hljs-symbol\"\u003e\nexample:\u003c/span\u003e:calculate_with_f64:\n        \u003cspan class=\"hljs-keyword\"\u003eaddsd\u003c/span\u003e   \u003cspan class=\"hljs-built_in\"\u003exmm0\u003c/span\u003e, \u003cspan class=\"hljs-built_in\"\u003exmm1\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003eret\u003c/span\u003e\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWell there's our answer. There's definitely more instructions to a conversion. What's interesting is just how many\nare actually added in the process. The conversion actually costs 3 instructions: moving the f64 in xmm0 -\u003e xmm1, moving\nthe 2 in edi into eax, and the actual conversion itself.\u003c/p\u003e\n\u003cp\u003eWhats even more interesting is what happens if we do a small change in the rust code and call \u003ccode\u003ecalculate_with_u32\u003c/code\u003e before\ncalling \u003ccode\u003ecalculate_with_f64\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-asm\"\u003e\u003cspan class=\"hljs-symbol\"\u003e\n.LCPI0_0:\u003c/span\u003e\n\u003cspan class=\"hljs-meta\"\u003e        .quad\u003c/span\u003e   \u003cspan class=\"hljs-number\"\u003e0x4000000000000000\u003c/span\u003e\n\u003cspan class=\"hljs-symbol\"\u003e.LCPI0_1:\u003c/span\u003e\n\u003cspan class=\"hljs-meta\"\u003e        .quad\u003c/span\u003e   \u003cspan class=\"hljs-number\"\u003e0x400c000000000000\u003c/span\u003e\n\u003cspan class=\"hljs-symbol\"\u003emain:\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003epush\u003c/span\u003e    \u003cspan class=\"hljs-built_in\"\u003erax\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003emov\u003c/span\u003e     \u003cspan class=\"hljs-built_in\"\u003eedi\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003emovsd\u003c/span\u003e   \u003cspan class=\"hljs-built_in\"\u003exmm0\u003c/span\u003e, \u003cspan class=\"hljs-built_in\"\u003eqword\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eptr\u003c/span\u003e [\u003cspan class=\"hljs-built_in\"\u003erip\u003c/span\u003e + .LCPI0_1]\n        \u003cspan class=\"hljs-keyword\"\u003ecall\u003c/span\u003e    example::calculate_with_u32\n        \u003cspan class=\"hljs-keyword\"\u003emovsd\u003c/span\u003e   \u003cspan class=\"hljs-built_in\"\u003exmm0\u003c/span\u003e, \u003cspan class=\"hljs-built_in\"\u003eqword\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eptr\u003c/span\u003e [\u003cspan class=\"hljs-built_in\"\u003erip\u003c/span\u003e + .LCPI0_0]\n        \u003cspan class=\"hljs-keyword\"\u003emovsd\u003c/span\u003e   \u003cspan class=\"hljs-built_in\"\u003exmm1\u003c/span\u003e, \u003cspan class=\"hljs-built_in\"\u003eqword\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eptr\u003c/span\u003e [\u003cspan class=\"hljs-built_in\"\u003erip\u003c/span\u003e + .LCPI0_1]\n        \u003cspan class=\"hljs-keyword\"\u003ecall\u003c/span\u003e    example::calculate_with_f64\n        \u003cspan class=\"hljs-keyword\"\u003epop\u003c/span\u003e     \u003cspan class=\"hljs-built_in\"\u003erax\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003eret\u003c/span\u003e\n\u003cspan class=\"hljs-symbol\"\u003e\nexample:\u003c/span\u003e:calculate_with_u32:\n        \u003cspan class=\"hljs-keyword\"\u003emovaps\u003c/span\u003e  \u003cspan class=\"hljs-built_in\"\u003exmm1\u003c/span\u003e, \u003cspan class=\"hljs-built_in\"\u003exmm0\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003emov\u003c/span\u003e     \u003cspan class=\"hljs-built_in\"\u003eeax\u003c/span\u003e, \u003cspan class=\"hljs-built_in\"\u003eedi\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003ecvtsi2sd\u003c/span\u003e        \u003cspan class=\"hljs-built_in\"\u003exmm0\u003c/span\u003e, \u003cspan class=\"hljs-built_in\"\u003erax\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003eaddsd\u003c/span\u003e   \u003cspan class=\"hljs-built_in\"\u003exmm0\u003c/span\u003e, \u003cspan class=\"hljs-built_in\"\u003exmm1\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003eret\u003c/span\u003e\n\u003cspan class=\"hljs-symbol\"\u003e\nexample:\u003c/span\u003e:calculate_with_f64:\n        \u003cspan class=\"hljs-keyword\"\u003eaddsd\u003c/span\u003e   \u003cspan class=\"hljs-built_in\"\u003exmm0\u003c/span\u003e, \u003cspan class=\"hljs-built_in\"\u003exmm1\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003eret\u003c/span\u003e\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt's actually fairly interesting in my mind, probably from utter lack of experience,\nbut we can really see some fascinating optimizations around computers.\u003c/p\u003e\n\u003ch2\u003eSome Questions and Thoughts\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eThere's something weird happening with storing in \u003ccode\u003eedi\u003c/code\u003e over \u003ccode\u003eeax\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eThe order of the constants inverted between .LCPI0_0 and .LCPI0_1 for no apparent reason.\u003c/li\u003e\n\u003cli\u003eCompilers are really, really cool\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI can't help but wonder exactly why 2 is stored in \u003ccode\u003eedi\u003c/code\u003e over preemptively storing the\nvalue into \u003ccode\u003eeax\u003c/code\u003e. If I had to take a blind guess, it may be that \u003ccode\u003erax\u003c/code\u003e or \u003ccode\u003eeax\u003c/code\u003e are\nreserved with the call instruction. That or it's bad practice as some functions may\npush \u003ccode\u003erax\u003c/code\u003e onto the stack (even though we can see that ours don't).\u003c/p\u003e\n\u003cp\u003ePreemptively pushing to \u003ccode\u003eeax\u003c/code\u003e would save the \u003ccode\u003emov\u003c/code\u003e from \u003ccode\u003eeax\u003c/code\u003e to \u003ccode\u003eedi\u003c/code\u003e in this scenario,\nbut in larger codebases, we may not know if the callee invokes \u003ccode\u003epush rax\u003c/code\u003e, which would\nthan corrupt \u003ccode\u003eeax\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eIt could also be that \u003ccode\u003eeax\u003c/code\u003e is reserved for function parameters. I have seen that mentioned\nonline, but no way of confirming either one really.\u003c/p\u003e\n\u003cp\u003eSide note: for those not entirely familiar with / newer to assembly (like myself) \u003ccode\u003eeax\u003c/code\u003e\nand \u003ccode\u003erax\u003c/code\u003e are basically one in the same ... but also not. \u003ccode\u003eeax\u003c/code\u003e is actually the lower\nbits of \u003ccode\u003erax\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eThe below is essentially a simple ASCII depiction of the \u003ccode\u003erax\u003c/code\u003e and \u003ccode\u003eeax\u003c/code\u003e registers.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-txt\"\u003e\n +-----------------------------------------------------+\n |                         rax                         |\n +--------------------------+--------------------------+\n |                          |                          |\n |                          |                          |\n |                          |                          |\n |           eax            |                          |\n |                          |                          |\n |                          |                          |\n |                          |                          |\n +--------------------------+--------------------------+\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou learn something new everyday!\u003c/p\u003e\n\u003cp\u003eNow as far as the change between the local constant LCPI0_0 and LCPI0_1. It appears that LCPI0_1 is called first in\nboth compiled assembly outputs. The difference is the functions they are being called for.\u003c/p\u003e\n\u003cp\u003eAnother blind guess, local constants are being tracked on a stack and then unwinding the stack is how they are established\nand labelled. The jury is also out on some small optimzation, but it's probably just a stack. Interesting nonetheless!\u003c/p\u003e\n\u003ch2\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eAssembly is actually pretty cool. I don't think I would ever want to write anything in pure assembly. But it really\nallows you to appreciate what the compiler is doing and peek behind the frontend of some of these languages.\u003c/p\u003e\n\u003cp\u003eWho knows, maybe there's more small posts like these to come.\u003c/p\u003e\n\u003cp\u003eUntil next time!\u003c/p\u003e"},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"the-cost-of-casting"},"buildId":"XPwiApdXAcqtI3u-hHfVF","assetPrefix":"https://nekevss.github.io","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>